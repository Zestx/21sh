I. GET_INPUT
	- Getting new lines at get_all_lines() with get_next_line().
		* Each extra lines is freed, only returning full_input.
	- Checking the full_input for syntax errors
		* If there's one, full_input is freed and null is returned.
	- If it's empty, just returning null.
	- The full_input (now just input) is returned.

II. TOKENIZE
	- We put a pointer on input to roam it and get tokens.
	- We get new tokens (see next step)
	- We free the original input and return a linked list of tokens.

III. GET_NEXT_TOKENS
	- Each token is lexed and allocated a node into a list of tokens.

IV. SPLIT_COMMAND (;)
	- init_tokens_group() is called
		* Allocating an array of t_tokens lists.
		* Each element of the array is set to NULL.
	- The original list is split regarding semicolumns into
	  the newly created array.
	- !!! We free the original tokens list with free_token_list();
	- returning the newly splitted array.

V. DISPATCH
	- the lists of toks_groups are sent one by one to dispatch
	- dispatch split each list into pipe nodes (see prev. step) put in
	  pipeline_cmds
	- we do not free the original list since they're freed in prompt_loop()
	  with free_token_group().
	- we iterate on pipeline_cmds to transform each list into a t_pnode
	  node.
		* all redir tokens of a node are put into a t_tokens*;
		* all args tokens of a node are put into a char**
VI. GATHER_REDIR_TOKENS
	- 
